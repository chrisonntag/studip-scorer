import getpass
import asyncio
import logging
import os
import configparser
import ssl
import time
from typing import List
from urllib.parse import urlencode
from weakref import WeakSet
from datetime import datetime
import aiohttp
from aiohttp import ClientError

from parsers import *


PROJ_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

config = configparser.RawConfigParser()
config.read(os.path.join(PROJ_DIR, 'config.cfg'))

BASE_URL = config.get('studip', 'base_url')
COURSE_ID = config.get('studip', 'course_id')
EXPIRE_TIME = config.getint('news', 'expire_time')
NEWS_DICT = {
        "topic": "Ankündigung vom {}",
        "body": "Dies ist eine automatisch generierte Ankündigung, um den Stud.IP Rang zu erhöhen. \nSie läuft um {} ab!",
        "expire": config.getint('news', 'expire_time'),
        "allow_comments": 1
        }
NEWS_DICT_WITH_RIVAL = {
        "topic": "Announcement from {}",
        "body": "This is an autogenerated announcement to generate more Stud.IP points than rival user {0}.\nWill expire at {1}.",
        "expire": EXPIRE_TIME,
        "allow_comments": 0
        }

class StudIPError(Exception):
    pass


class LoginError(StudIPError):
    pass


class StudIPScoreSession:
    def __init__(self, user, password, loop):
        self.user = user
        self.password = password
        self._studip_base = 'https://studip.uni-passau.de'
        self._sso_base = 'https://sso.uni-passau.de'

        self._background_tasks = WeakSet()  # TODO better management of (failing of) background tasks
        if not loop:
            self._loop = asyncio.get_event_loop()
        else:
            self._loop = loop

        context = ssl._create_unverified_context()

        connector = aiohttp.TCPConnector(loop=self._loop, limit=10,
                                         keepalive_timeout=30,
                                         force_close=False,
                                         ssl=context)
        self.ahttp = aiohttp.ClientSession(connector=connector, loop=self._loop,
                                           read_timeout=30,
                                           conn_timeout=30)

    def _sso_url(self, url):
        return self._sso_base + url


    def _studip_url(self, url):
        return self._studip_base + url


    async def close(self):
        try:
            for task in self._background_tasks:
                task.cancel()
        finally:
            if self.ahttp:
                await self.ahttp.close()

    async def do_login(self):
        try:
            async with self.ahttp.get(self._studip_url("/studip/index.php?again=yes&sso=shib")) as r:
                post_url = parse_login_form(await r.text())
        except (ClientError, ParserError) as e:
            raise LoginError("Could not initialize Shibboleth SSO login") from e

        try:
            async with self.ahttp.post(
                    self._sso_url(post_url),
                    data={
                        "j_username": self.user,
                        "j_password": self.password,
                        "uApprove.consent-revocation": "",
                        "_eventId_proceed": ""
                    }) as r:
                form_data = parse_saml_form(await r.text())
        except (ClientError, ParserError) as e:
            raise LoginError("Shibboleth SSO login failed") from e

        try:
            async with self.ahttp.post(self._studip_url("/Shibboleth.sso/SAML2/POST"), data=form_data) as r:
                await r.text()
                if not r.url.path.startswith("/studip"):
                    raise LoginError("Invalid redirect after Shibboleth SSO login to {}".format(r.url))
        except ClientError as e:
            raise LoginError("Could not complete Shibboleth SSO login") from e


    async def get_user_id(self):
        async with self.ahttp.get(self._studip_url("/studip/api.php/user")) as r:
            response = await r.json()
            return response['user_id']


    async def create_news(self, form_data, course_id):
        from datetime import datetime, timedelta

        post_date = datetime.now()
        end_date = datetime.now() + timedelta(seconds=EXPIRE_TIME)
        form_data['topic'] = form_data['topic'].format(post_date.strftime('%d. %b %Y um %H:%M'))
        form_data['body'] = form_data['body'].format(end_date.strftime('%H:%M Uhr'))

        async with self.ahttp.post(self._studip_url("/studip/api.php/course/{}/news".format(course_id)), data=form_data) as r:
            await r.text()
            if r.status == 200 or r.status == 201:
                response_data = await r.text()
                return True
            else:
                response_data = await r.text()
                print('Failure with HTTP Status Code %d' % r.status)
                print(r.request_info)
                print(str(response_data))
                return False


    async def create_news_for_rival(self, form_data, course_id, user, rival_user, points_threshold):
        rival_score = 0
        try:
            async with self.ahttp.get(self._studip_url("/studip/dispatch.php/profile?username={}".format(rival_user))) as r:
                rival_score = parse_user_points(await r.text())
        except (ClientError, ParserError) as e:
            raise StudIPError("Could not retrieve user score for user {}".format(rival_user)) from e
        own_score = 0
        try:
            async with self.ahttp.get(self._studip_url("/studip/dispatch.php/profile?username={}".format(user))) as r:
                own_score = parse_user_points(await r.text())
        except (ClientError, ParserError) as e:
            raise StudIPError("Could not retrieve user score for user {}".format(user)) from e

        difference = own_score - rival_score
        if difference > points_threshold:
            print("Your score: {}\nRival score: {}\nPoint difference to rival {} is {} points. No announcement will be made.".format(own_score, rival_score, rival_user, abs(difference)))
            return False

        print("Your score: {}\nRival score: {}\nPoint difference to rival {} is {} points. Creating announcement.".format(own_score, rival_score, rival_user, abs(difference)))

        from datetime import datetime, timedelta

        post_date = datetime.now()
        end_date = datetime.now() + timedelta(seconds=EXPIRE_TIME)
        form_data['topic'] = form_data['topic'].format(post_date.strftime('%d. %b %Y at %H:%M'))
        form_data['body'] = form_data['body'].format(rival_user, end_date.strftime('%H:%M'))

        async with self.ahttp.post(self._studip_url("/studip/api.php/course/{}/news".format(course_id)), data=form_data) as r:
            await r.text()
            if r.status == 200 or r.status == 201:
                response_data = await r.text()
                return True
            else:
                response_data = await r.text()
                print('Failure with HTTP Status Code %d' % r.status)
                print(r.request_info)
                print(str(response_data))
                return False


def main():
    username = config.get('studip', 'username')
    password = config.get('studip', 'password')
    rival_username = config.get('rival', 'username', fallback='')

    event_loop = asyncio.get_event_loop()
    session = StudIPScoreSession(username, password, event_loop)

    try:
        event_loop.run_until_complete(session.do_login())
        if not rival_username:
            event_loop.run_until_complete(session.create_news(NEWS_DICT, COURSE_ID))
        else:
            points_threshold = config.getint('rival', 'threshold', fallback=250)
            event_loop.run_until_complete(session.create_news_for_rival(NEWS_DICT_WITH_RIVAL, COURSE_ID, username, rival_username, points_threshold))
    finally:
        async def shutdown_session_async(session):
            await session.close()

        event_loop.run_until_complete(shutdown_session_async(session))

